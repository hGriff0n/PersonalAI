
Project:
  Implement routing of messages
    implement client+app
      stress testing (all tests should work with multiple clients)
        <- client can call a server that immediately crashes
          this'll test the "server exit" control flow
        <- client can call a server and immediately crashes
          -> this needs a server in a separate script
          this'll test the "client exit" control flow
          the server here should delay for a minute before responding
      change server error handling
        dispatch should not use raw `json!` when producing error messages
          should instead produce from a `rpc::Error` class and the serialize it to the dictionary
      produce module setup and testing "framework"
        <- how to utilize mypy?
        make `setup.py` replacement
          <- move code into subfolder
        make `launch.py` replacement
      is there a way to setup these integration tests?
        also look at setting up unit tests in the rust and python code
        can also use a library (ex pydantic) that enforces these hints at runtime
    change server error handling to use custom error type [[desktop]]
      create custom error type that is serializable to a dictionary
        -> need to replace usage of raw `json!` when producing the error message
          is there a way I can create a small map (from 'error' -> error) and then send that?
      convert all existing code to use the new error type
        rpc/mod.rs:
          service def returns std::io::Error
          __wrap_user_body expects rpc body to return a std::io::Error
          registration returns Result<(), String>
        rpc/dispatch.rs:
          raw `json!` commands are used to produce the error messages which are sent
        rpc/service.rs:
          register_endpoints returns Result<(), String>
        rpc/types.rs:
          Result type has an `Error=std::io::Error`
        state/client.rs:
          'on_exit' callback returns a Result<(), std::io::Error>
          run_exit_callbacks returns a Result<(), std::io::Error>
          drop_client returns a Result<(), std::io::Error>
        state/routing.rs:
          drop_client returns a Result<(), std::io::Error>
        registration_service.rs:
          register_app_impl returns a Result<Vec<String>, std::io::Error>
    implement deregister
      add handle for `deregister` request
        drop all messages in flight to that app
    create a way to call internal functions through the rpc channel
    move services into `server/src/services`
      improve the organization of `server/src/state/`
  Read through old code to see what's now missing
    -> seshat/indexer
      the current codebase doesn't really fit that too well
  Clean up the codebase and ensure everything is well architected
    How will I get server state data into the rpc service handlers?
    Add comments to all of the classes and the functions
    Improve the organization of the python code
  Integrate with CLI args
    add clap to rust server
      add `add_args<'a, 'b>(app: clap::App<'a, 'b>) -> clap::App<'a, 'b>`
      -> basically can just take server.rs (+ others?)
    add whatever python cli thing I used
      get python code to the level of completeness as in the old codebase
    <- maybe have config files instead
      -> isn't this supported already
  Integrate with logging
    add logging.rs to server
      <- introduce logging calls where needed
    add whatever python logging thing I used
  Release the new framework
    Delete the old code and move this code to the "main" sections
    Create setup.py and launch.py variants

Improvements:
  Integrate with monitoring
    find monitoring framework
      -> https://crates.io/crates/metered
  Implement device routing (a location service, kinda)
    implement register_device
    <- client that registers a device server (use two for testing)
    <- client that uses device server
    implement various "read_state" rpcs
      implement `get_registered_devices` rpc
    determine rpc options to request device routing
    modify routing to use devices if provided
    add ability to set modality information
      <- mac address, status, name, etc.
      <- would be put in `plugins.Client` (similar to `plugins.AppServer`)
  Introduce rpc timeouts
    NOTE: Any solution here will likely also work for when a client exits while waiting on in-flight messages
  Think about network/device monitoring situation
  Think about ways to allow for multiple handles to be registered to one rpc
    <- may not be desired
  Think about ways to allow for subscriptions/alerts to be registered+produced
  Current design work and focus assumes the "distributed follys"
    Look at ways of making the handling code more robust
    implement message timeouts (for server and forwarding requests) <- rpc timeouts?
      if a message takes too long, a timeout error is sent back instead
      if a message is being processed by an app, and the app is taken offline to upgrade it
  Implement security module
  Implement pastry distributed FS (or distributed hash table)
    implement local indexer (client?)
      -> implementing as a client would require a FsUpdateService to handle indexer updates
    implement seshat search engine service

Communication:
  would be nice to "chain" calls
    ie. find file > streamto device > play_music
      the response for `find file` triggers `streamto device` on the server, not the client
      not sure how necessary this would actually be
    we could implement a `setup_direct_connection` call to enable this?

Tech Debt:
  Look at modifying rpc_service! macro to inject the protocol through generics on the methods/struct
  rpc::Message requires JsonProtocol
    Need to convert to using a configurable protocol type
      Don't know how to do this in rust
        -> `#[cfg(True)] type P = JsonProtocol; #[cfg(false)] type P = DummyProtocol;`?
          <- this is largely due to the macros (otherwise i'd use polymorphism)
