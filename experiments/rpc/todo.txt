
Server:
  Implement routing of messages
    implement client+app
      <- final products:
        app the exports a few interfaces
        client that calls an rpc exported by the previously registered app
      improve serialization code to enable message checking
        check that the untyped message is extractable into our message
      produce module for asynchronous request/response handling
        <- this is on top of the previous module
          NOTE: Even clients will use this for their communications
          This defines the underlying communication layer (ie. handling Messages)
            <- only difference may be in the specific handler that gets used
      produce module for registering rpc endpoints
      produce dispatcher utilizing the rpc module
      produce app using the dispatcher
        produce a second app to test out any module inefficiencies
      produce a client using the modules
        produce a second client to test out any module inefficiencies
        test out that both clients work with both apps
          <- test out that I can register both apps and use them in a client
      stress testing (all tests should work with multiple clients)
        <- client can call app server
        <- client can call multiple app servers
        <- client can call app server which calls an app server
        <- client can call a server that immediately crashes
          this'll test the "server exit" control flow
        <- client can call a server and immediately crashes
          this'll test the "client exit" control flow
          the server here should delay for a minute before responding
      produce module setup and testing "framework"
        run mypy on the entry script and check that it "types"
      is there a way to setup these integration tests?
        also look at setting up unit tests in the rust and python code
        can also use a library (ex pydantic) that enforces these hints at runtime
    implement deregister
      add handle for `deregister` request
        drop all messages in flight to that app
      automatically `deregister` on client shutdown
    move services into `server/src/services`
      improve the organization of `server/src/state/`
  Read through old code to see what's now missing
    -> seshat/indexer
      the current codebase doesn't really fit that too well
    -> logging
    -> cli args
    -> custom error types (ie. not routing everything through std::io::Error)
  Clean up the codebase and ensure everything is well architected
    Produce rpc/protocol helper methods for python
    Produce python structure code
    How will I get server state data into the rpc service handlers?
    Add comments to all of the classes and the functions
  Integrate with monitoring
    find monitoring framework
      -> https://crates.io/crates/metered
  Implement device routing (a location service, kinda)
    implement register_device
    <- client that registers a device server (use two for testing)
    <- client that uses device server
    implement various "read_state" rpcs
      implement `get_registered_devices` rpc
    determine rpc options to request device routing
    modify routing to use devices if provided
  Introduce rpc timeouts
    NOTE: Any solution here will likely also work for when a client exits while waiting on in-flight messages
  Think about network/device monitoring situation
  Think about ways to allow for multiple handles to be registered to one rpc
    <- may not be desired
  Think about ways to allow for subscriptions/alerts to be registered+produced
  Current design work and focus assumes the "distributed follys"
    Look at ways of making the handling code more robust
    implement message timeouts (for server and forwarding requests)
      if a message takes too long, a timeout error is sent back instead
      if a message is being processed by an app, and the app is taken offline to upgrade it
  Setup project (replace old version)
    introduce logger calls into the new version
      -> logging.rs can stay as-is
    integrate new version with clap
      add `add_args<'a, 'b>(app: clap::App<'a, 'b>) -> clap::App<'a, 'b>`
      -> basically can just take server.rs (+ others?)
  Implement security module
  Implement pastry distributed FS (or distributed hash table)
    implement local indexer (client?)
      -> implementing as a client would require a FsUpdateService to handle indexer updates
    implement seshat search engine service

Modalities:
  Wrap communication code in functions
  Create RPC handling code module
  Enable app/server split in client code
    decide on python architecture for split
    make a "FortuneTeller" client
    make an app that calls into the "FortuneTeller" client
  Read through old code to see what's now missing
  ...
  Setup project (replace old version)

Communication:
  would be nice to "chain" calls
    ie. find file > streamto device > play_music
      the response for `find file` triggers `streamto device` on the server, not the client
      not sure how necessary this would actually be
    we could implement a `setup_direct_connection` call to enable this?

Weird Errors:
  Hitting ctrl-c on the server sometimes produces a STATUS_CONTROL_C_EXIT error
    this is random and occurs regardless of rpc implementation

Tech Debt:
  Look at modifying rpc_service! macro to inject the protocol through generics on the methods/struct
  rpc::Message requires JsonProtocol
    Need to convert to using a configurable protocol type
      Don't know how to do this in rust
        -> `#[cfg(True)] type P = JsonProtocol; #[cfg(false)] type P = DummyProtocol;`?
          <- this is largely due to the macros (otherwise i'd use polymorphism)
