
Server:
  Implement routing of messages
    implement app forwarding in server
      figure out how to recognize which "messages" are being handled by a specific app
        <- This is necessary for deregistration, but the forwarding implementation should be setup to support it
      figure out if there's any issues with spawning a handle and then closing the connection
        <- I think yes, is there anyway to force a handle to close if it's connection closes
          probably through join on the futures/etc. (would be added in the dispatch code)
    implement client
      <- client that calls an rpc exported by the previously registered app
      asynchronous request and response handling
      wrapping of communication code in a common module
      dispatcher that receives messages and forwards them to method calls
        <- is there a way to automatically parse the json message to a specific type
        `dispatcher.register("endpoint", self.endpoint)`
    implement deregister
      add handle for `deregister` request
        drop all messages in flight to that app
      automatically `deregister` on client shutdown
    move services into `server/src/services`
      <- figure out a place to move the client tracking structs to (device?)
  Read through old code to see what's now missing
    -> seshat/indexer
      the current codebase doesn't really fit that too well
    -> logging
    -> cli args
    -> custom error types?
  Clean up the codebase and ensure everything is well architected
    Produce rpc/protocol helper methods for python
    Produce python structure code
    How will I get server state data into the rpc service handlers?
  Integrate with monitoring
    find monitoring framework
      -> https://crates.io/crates/metered
  Implement device routing (a location service, kinda)
    implement register_device
    <- client that registers a device server (use two for testing)
    <- client that uses device server
    implement various "read_state" rpcs
      implement `get_registered_devices` rpc
    determine rpc options to request device routing
    modify routing to use devices if provided
  Think about network/device monitoring situation
  Think about ways to allow for multiple handles to be registered to one rpc
    <- may not be desired
  Think about ways to allow for subscriptions/alerts to be registered+produced
  Current design work and focus assumes the "distributed follys"
    Look at ways of making the handling code more robust
    implement message timeouts (for server and forwarding requests)
      if a message takes too long, a timeout error is sent back instead
      if a message is being processed by an app, and the app is taken offline to upgrade it
  Setup project (replace old version)
    introduce logger calls into the new version
      -> logging.rs can stay as-is
    integrate new version with clap
      add `add_args<'a, 'b>(app: clap::App<'a, 'b>) -> clap::App<'a, 'b>`
      -> basically can just take server.rs (+ others?)
  Implement security module
  Implement pastry distributed FS (or distributed hash table)
    implement local indexer (client?)
      -> implementing as a client would require a FsUpdateService to handle indexer updates
    implement seshat search engine service

Modalities:
  Wrap communication code in functions
  Create RPC handling code module
  Enable app/server split in client code
    decide on python architecture for split
    make a "FortuneTeller" client
    make an app that calls into the "FortuneTeller" client
  Read through old code to see what's now missing
  ...
  Setup project (replace old version)

Communication:
  would be nice to "chain" calls
    ie. find file > streamto device > play_music
      the response for `find file` triggers `streamto device` on the server, not the client
      not sure how necessary this would actually be
    we could implement a `setup_direct_connection` call to enable this?

Weird Errors:
  Hitting ctrl-c on the server sometimes produces a STATUS_CONTROL_C_EXIT error
    this is random and occurs regardless of rpc implementation

Tech Debt:
  Look at modifying rpc_service! macro to inject the protocol through generics on the methods/struct
  rpc::Message requires JsonProtocol
    Need to convert to using a configurable protocol type
      Don't know how to do this in rust
        -> `#[cfg(True)] type P = JsonProtocol; #[cfg(false)] type P = DummyProtocol;`?
          <- this is largely due to the macros (otherwise i'd use polymorphism)
