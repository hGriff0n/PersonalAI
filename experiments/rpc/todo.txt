
Server:
  Implement routing of messages
    collect requirements
    implement register_app
      modify registration methods to allow failure of registration
        <- if handle in map, don't insert and return status
          NOTE: We may allow for multiple handles in the future, but for now this is better
      come up with method for passing device/rpc state to Services and allowing for modifications there
        <- then use that method to give the RegistrationService access to rpc registration
      come up with a better way of tracking handle registration
        current arch assumes that we only register new handles, never remove old ones
        there may be an efficient way to do both
          <- otherwise it's just a `app -> [handles]` map
      implement tracking of registered apps
        <- do i also want to track all registered connections? may help with close signal handling
    think about what a client app will need to work
      <- testing at this stage can be done by just sending a message
      asynchronous request and response handling
      wrapping of communication code in a common module
      dispatcher that receives messages and forwards them to method calls
        <- can I use decorators to mark out which functions are rpc endpoints?
          <- can that be used to then automatically register app services in the app dispatcher?
        <- is there a way to automatically parse the json message to a specific type
        `dispatcher.register("endpoint", self.endpoint)`
    implement app forwarding in server
      setup communication channel to enable sending requests to the app
        <- could we reuse the "sink/source" from `serve`]
      implement way to detect app responses inside of read workflow
        for now just don't send responses into dispatch
    implement client
      <- client that calls an rpc exported by the previously registered app
    implement deregister
      add handle to automatically deregister apps on client shutdown
    move services into service folder
  Read through old code to see what's now missing
    -> seshat/indexer
      the current codebase doesn't really fit that too well
    -> logging
    -> cli args
  Clean up the codebase and ensure everything is well architected
    Produce rpc/protocol helper methods for python
    Produce python structure code
    I currently have two supported ways for registering callbacks, reduce to one?
      Both get autogenerated in the `rpc_service!` macro
      They both go through the same codepath, though it may be confusing
        <- add_service: Service exports Vec<(name, callback)>
          dispatcher iterates over this and calls Registry::register for each method
        <- register: dispatcher method that gets called once for each endpoint
    How will I get server state data into the rpc service handlers?
  Integrate with monitoring
    find monitoring framework
      -> https://crates.io/crates/metered
  Implement device routing (a location service, kinda)
    implement register_device
    <- client that registers a device server (use two for testing)
    <- client that uses device server
    implement various "read_state" rpcs
      implement `get_registered_devices` rpc
    determine rpc options to request device routing
    modify routing to use devices if provided
  Think about network/device monitoring situation
  Think about ways to allow for multiple handles to be registered to one rpc
    <- may not be desired
  Think about ways to allow for subscriptions/alerts to be registered+produced
  Current design work and focus assumes the "distributed follys"
    Look at ways of making the handling code more robust
    implement message timeouts (for server and forwarding requests)
      if a message takes too long, a timeout error is sent back instead
      if a message is being processed by an app, and the app is taken offline to upgrade it
  ...
  Setup project (replace old version)
    introduce logger calls into the new version
      -> logging.rs can stay as-is
    integrate new version with clap
      add `add_args<'a, 'b>(app: clap::App<'a, 'b>) -> clap::App<'a, 'b>`
      -> basically can just take server.rs (+ others?)
  Implement security module
  Implement pastry distributed FS (or distributed hash table)
    implement local indexer (client?)
      -> implementing as a client would require a FsUpdateService to handle indexer updates
    implement seshat search engine service

Modalities:
  Wrap communication code in functions
  Create RPC handling code module
  Enable app/server split in client code
    decide on python architecture for split
    make a "FortuneTeller" client
    make an app that calls into the "FortuneTeller" client
  Read through old code to see what's now missing
  ...
  Setup project (replace old version)

Communication:
  would be nice to "chain" calls
    ie. find file > streamto device > play_music
      the response for `find file` triggers `streamto device` on the server, not the client
      not sure how necessary this would actually be
    we could implement a `setup_direct_connection` call to enable this?

Weird Errors:
  Hitting ctrl-c on the server sometimes produces a STATUS_CONTROL_C_EXIT error
    this is random and occurs regardless of rpc implementation

Tech Debt:
  Look at modifying rpc_service! macro to inject the protocol through generics on the methods/struct
  rpc::Message requires JsonProtocol
    Need to convert to using a configurable protocol type
      Don't know how to do this in rust
        -> `#[cfg(True)] type P = JsonProtocol; #[cfg(false)] type P = DummyProtocol;`?
          <- this is largely due to the macros (otherwise i'd use polymorphism)
