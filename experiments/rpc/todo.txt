
Project:
  Implement routing of messages
    implement deregister
      add handle for `deregister` request
        drop all messages in flight to that app
    move services into `server/src/services`
      improve the organization of `server/src/state/`

  register modalities/devices with the Syncer
    add 'add_modality' and 'kill_modality' handles to server
      add modality tracking
        <- generate modality_id at startup
      add device details extraction from 'add_modality' endpoint
        <- find way to map multiple modalities to one device
    add 'kill_modality' handle to server
      <- just closing the handle will do it
    add 'drop_device' handle to server
      <- kill all modalities on the given device
    change the autogenerated "Syncer" client to send the 'add'/'kill' commands
      need to collect device data and forward it on too

  Clean up the codebase and ensure everything is well architected
    Improve the rust error handling
    Add retry handling to python socket connect

    improve python logging
      look at adding decorators to log method calls
      look at logging cookbook
      look at removing "logger" passing to threads through the comm handler?

    improve rust logging
      try to rework the log system to have more structured output

  Release the new framework
    Delete the old code and move this code to the "main" sections
    Tidy up the code organization a little bit
    Implement existing plugins/modalities
      <- including the config parser generators


Improvements:
  Create a way to call internal functions through the rpc channel
    <- do server internal computation by calling the rpc endpoint (gets dispatched to server)

  Create a way to dynamically load modules into the device_manager
    This would also allow for specifying command-line arguments (if possible)
      might have to setup some config system (or side-rpc channel, etc.)

  Integrate with monitoring
    find monitoring framework
      -> https://crates.io/crates/metered

  Implement device routing (a location service, kinda)
    implement register_device
    <- client that registers a device server (use two for testing)
    <- client that uses device server
    implement various "read_state" rpcs
      implement `get_registered_devices` rpc
    determine rpc options to request device routing
    modify routing to use devices if provided
    add ability to set modality information
      <- mac address, status, name, etc.
      <- would be put in `plugins.Client` (similar to `plugins.AppServer`)

  Convert python rpc messages to using pydantic
    Simpler enforcement of conversion type rules

  Introduce rpc timeouts
    NOTE: Any solution here will likely also work for when a client exits while waiting on in-flight messages

  Develop server to use rpcs for internal functions
    -> would require load-balancing and other monitoring functionality
    -> may want to add similar functionality in python (for calling services in the same modality)

  Think about network/device monitoring situation
  Think about ways to allow for multiple handles to be registered to one rpc
    <- may not be desired
  Think about ways to allow for subscriptions/alerts to be registered+produced

  Unit tests and Integration tests for python and rust

  Current design work and focus assumes the "distributed follys"
    Look at ways of making the handling code more robust
    implement message timeouts (for server and forwarding requests) <- rpc timeouts?
      if a message takes too long, a timeout error is sent back instead
      if a message is being processed by an app, and the app is taken offline to upgrade it

  Implement security module

  Implement pastry distributed FS (or distributed hash table)
    implement local indexer (client?)
      -> implementing as a client would require a FsUpdateService to handle indexer updates
    implement seshat search engine service


Communication:
  would be nice to "chain" calls
    ie. find file > streamto device > play_music
      the response for `find file` triggers `streamto device` on the server, not the client
      not sure how necessary this would actually be
    we could implement a `setup_direct_connection` call to enable this?


Tech Debt:
  Look at modifying rpc_service! macro to inject the protocol through generics on the methods/struct
  rpc::Message requires JsonProtocol
    Need to convert to using a configurable protocol type
      Don't know how to do this in rust
        -> `#[cfg(True)] type P = JsonProtocol; #[cfg(false)] type P = DummyProtocol;`?
          <- this is largely due to the macros (otherwise i'd use polymorphism)
