NOTE: The app will be responsible for sending a deregister request to the server
  the server only sends messages to servers/devices
NOTE: All apps should also support some basic monitoring/discovery calls by default
  these allow the server to request information about app health/etc.
  TODO: How will these be "registered" - only the server should be able to call these apps
    Should the server just assume that these handles exist?

app sends register_app request (NOTE: Finished server)
  -> server receives request (NOTE: Automatic)
  -> server dispatches on request (NOTE: Automatic)
    <- finds RegistrationService (NOTE: Done)
  -> server sends request to RegistrationService::register_server (NOTE: Automatic)
    -> register_server extracts list of handles (NOTE: Automatic)
    -> register_server sets up communication channel (NOTE: Done)
        NOTE: Pushing things on the write channel will currently cause infinite loops with the response
          Would need to change handling of read workflow slightly (see later)
    -> register_server registers callback for each handles (NOTE: Done)
    <- register_server sends back registered handles (NOTE: Done)
  -> server checks response for messages (NOTE: Automatic)
    <- response has message (NOTE: Automatic)
  <- server sends response back to app (NOTE: Automatic)
-> app handles response (NOTE: Implementation detail)

client sends app request (NOTE: Done)
  -> server receives request (NOTE: Automatic)
  -> server dispatches on request (NOTE: Automatic)
    <- dispatch points to an app server (NOTE: Done)
    <- server installs system to reroute responses to the original message (NOTE: Done)
      ISSUE: Some apps may not return anything. How to handle?
    <- server sends message to app write queue (NOTE: Done)
  -> app handles message (NOTE: Done)
    -> app receives request (NOTE: Done)
    -> app dispatches on request to endpoint (NOTE: Done)
      <- find registered endpoint method (NOTE: Done)
      <- run endpoint method (NOTE: Done)
      <- parse back response into message (NOTE: Done)
    <- app writes response to server (NOTE: Done)
  -> server receives response (NOTE: Automatic)
  -> server dispatches on response (NOTE: Done)
    <- dispatch points to a "forwarding table" (NOTE: Done)
    <- response is sent to requestor's write queue (NOTE: Done)
    <- server sends response to requestor (NOTE: Automatic)
  -> app handles response (NOTE: Done)
client handles response (NOTE: Done)

app sends deregister request (TODO: Implement 'deregister')
  -> server receives `deregister` request (TODO: 'deregister' isn't publicly implemented yet)
  -> server dispatches on request (NOTE: Automatic)
    <- finds RegistrationService (NOTE: Done)
  -> server sends request to RegistrationService::deregister (TODO: Is this the best way to approach it?)
    <- server handles are removed from dispatcher (NOTE: Automatic)
    <- in flight server messages are dropped (TODO: How to track these messages?)
    NOTE: We do not want to forcibly close the connection here in case the server just wants to reset
  -> server sends no response (TODO: Wanted?)

app gets dropped (TODO:)
  -> server recognizes dropped client (NOTE: Automatic)
  -> server dispatches on `deregister` request (TODO: Recognize and send)
    TODO: How to construct this request in the expected way?
    TODO: How to determine which request to send
    <- find RegistrationService (NOTE: Done)
  -> server sends request to RegistrationService::deregister (TODO:)
  -> server closes the client connection (NOTE: Automatic)

notes:
  this will require more work on making the serving+rpc code asynchronous
    server can't wait for a long running app request
