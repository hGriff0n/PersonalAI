

Short Term:
  Implement file system searcher to handle music files
    Reverse Engineer File Metadata parsing for mp3 files
    Implement modular file crawler
      Should be able to dynamically load "plugins" to handle specific file types
        Work on making this doable at runtime (add a pause to main)
      Do a lot of performance work to make it really fast
        Work on making this multi-threaded
        Look at ripgrep (blog and codereview)
    Implement indexer to run off of the results of the crawler
      The crawler will put data into a queue for the indexer to work off of
    Develop basic search system just to see the capabilities
    Turn a lot of these "sub-projects" into usable crates
      This is especially the case for 'tags' (as it's replacing taglib)
  Move dispatch modality into ai-manager orbit
    Rewrite routing process inside of device-manager
      Think about how the new flow will act/look and optimize on that
    Implement handling inside of the ai-manager
      See what aspects I'd be able to extract into the server crate
    Extract loader.py into the common (or scripts) directory

Produce a short video of the project

Medium Term:
  Vastly improve the available music files
    last option is to produce my own file search engine
      this engine should be very modular in all regards
        so have file-type level indexers (so music files are parsed by metadata, text files could be parsed by their contents, have a default)
      use ML to implement the searching
        make sure to put this project on github (advertise to community?)
    os-query may be a better platform to develop off of (maybe make rust bindings for it)
      Need to see if it can perform queries on music files (introspection beyond mp3 is nice)
    Look at fselect for producing the file list
      It's not developed as a library per-se though
      The server provides a set of "services" (API) that utilities can use
        This "File search" is one of them: Give the query json, get the file path
        The dispatch app queries the server for this path and sends the response to the audio app
      Come up with a generalizable way of producing these api endpoints (and their implementations)
  It would be nice if the server could spawn up "One-time use" plugins as needed
  Improve the handshaking procedure to actually have some degree of security and utility
    Current system only works because I have everything hardcoded
  Improve launch script to incorporate some file watching
    Automatically run `setup.py install --user` if anything in the setup script/packages have changed
      Automatically run "build" if cargo modules change

Long Term:
  Develop my own NLP system for decoding the purpose of messages (Wit doesn't seem to want to adapt)
  Figure out how the device manager is supposed to act if I add in an AI node
    I suppose in the final system, the AI node gets setup first, so the server addr exists
    We can also use the udp broadcast system to handle this possibility
      Would need to modify the launcher script to wait until the manager has found the server
  Switch over networking to use udp broadcasting to determine where the servers are
    I'm hardcoding the locations for now as that is simpler for my initial development
// https://github.com/jholtmann/ip_discovery - can use this script during client startup
            // https://gist.github.com/rsolomo/8703190

Errors/Fixes:
  Fix the device-manager refusing to stop running
    It's some wierd nonsense with tokio
  Fix the issues with quit/stop behavior (Seem to have brought everything to a halt)
    Have wit recognize 'quit' and 'stop'
      Wit is absolutely unable to recognize 'quit' as anything other than a search query
    Might want to swap out for LUIS (or even roll my own solution)
