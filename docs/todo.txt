

Short Term:
  Integrate Seshat with device-manager
    Fix the 'wit' import error
      `python setup.py install --user` has some errors with pyaudio
        src/_portaudiomodule.c(29): fatal error C1083: Cannot open include file: 'portaudio.h': No such file or directory
        error: Setup script exited with error: command 'C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.15.26726\\bin\\HostX86\\x64\\cl.exe' failed with exit status 2b
        NOTE: This is causing the wit dependency to not be installed, leading to the error
    Merge `DeviceCallback`
    Enable plugins to have different log levels
      clg.CommandLine currently ignores them because they're not specified in the config yaml
        TODO: Need a way to add in default plugin args
    Reintegrate the audio app with the new search functionality
      Ensure the audio app works on the desktop
      Rewrite the audio app completely
      Improve logging support in the audio app
  Improve system performance and granularity
    Enable stopping the device-manager internally
      The `select2(cancel)` in 'main.rs' should work, but it doesn't seem to
    Remove the startup penalty when dealing with the indexer (threading daemon)
      Startup time when an index cache file delays plugin handshakes
        When a re-crawl is being performed, no connections will be handled
      Would need to add a way to indicate a "reindex" is currently being performed in the return results
    Look at adding Notifications to the communication spec
      Right now, it's up to the server implementation about how to respond
        It would be nice to be able to specify that on the client side
    Find a way to "pretty-print" the time information inside of the log messages
  Add in "device-querying" capabilities to the cli interface
    Change cli app to have a 'cmd' mode and a 'chat' mode
      'chat' is the current (and would be default) operation
        NOTE: The "default" nature should probably be configurable
      'cmd' would basically interface like a linux command line
        Would have much more power and system access in 'cmd' mode
        NOTE: This is because everything in 'chat' mode would have to go through the dispatcher
    Come up with a data-collection framework both in python and rust
      https://github.com/performancecopilot/hornet
    Enable querying of that data
    Add ability for plugins to communicate "command syntax" with cli app
  Improve documentation and specifications
    Fill in architecture specification
    Come up with more message spec ideas
    Add in documentation about how to launch everything
    Improve documentation on system design
  Integrate an app "privilege" system to improve security
    Look into ways of "certifying" apps to prevent loading plugins "erroneously"
  Cleanup the "Medium Term" checklist
    Plan out the next dev work cycle

Produce a short video of the project

Medium Term:
  Integrate tf-idf ranking into seshat (or at least filter out common words)
    Investigate ways of integrating machine learning into the search results
    Investigate ways of handling misspellings in search queries
  Improve documentation
    Better document how the plugin configuration files are processed
      Also see if there's a way to have multiple config files (aggregation)
  Look into auto-generating the python message class
    Rust code works alot better by specifying the message as a struct
  Add in ability to handle a 'quit-all' command in the device-manager
    Consider changing `cli > "quit"` to produce this command
    NOTE: This may be better reserved for when we actually migrate to a fully distributed setup
      I think we'll have to rethink alot of the design/architecture of this system then anyways
  Add ability to dynamically register python "apps"
    ie. send "stop" from cli, then relaunch cli from separate terminal, continue running
  Add ability to dynamically load "plugins" for specific file types
    https://github.com/emoon/dynamic_reload
    NOTE: If we do the dynamic reloading, we'd also need to allow for the python modules to be reloaded
  Rework routing to follow a "kubernetes" style system
    Unify 'sender' and 'dest' into the same structure
    Allow for plugins to sign up under multiple "labels"
    Enable querying plugins based on the join of these labels
  Improve message routing to prevent looping messages (particularly broadcasts)
  Optimize rust and python codebases
    Improve usage of rust features, streamline memory usage particularly
    Look at ripgrep (blog and codereview) for optimization ideas
      https://gist.github.com/jFransham/369a86eff00e5f280ed25121454acec1
    Upgrade rust to rust 2018
      Improve errors to all use a common error type (enum type like fern::InitError)
    Handle unrecognized command line arguments
      Apparently clap doesn't natively support this
      https://github.com/clap-rs/clap/blob/eac457bdb095dade2efadd033af8d33e9c296f08/src/app/parser.rs
        The `get_matches_with` method immediately returns with an `Error::unknown_argument` when an unknown_argument is encountered
          I'd like it to instead just ignore these arguments and continue with parsing
          Apparently, there are cli utilities that allow for ignoring unknown arguments
  Implement system process to write index data to a cache file
  Distribute ai processing into separate nodes (basically split the device-manager into the ai-manager)
    Rewrite routing process inside of device-manager
      We need to be able to generically indicate which messages have to be forwarded to the ai-manager
      Optimize the new message and communication flows (to minimize number of messages)
      NOTE: Some messages we'll be able to handle locally (some we'll have to)
    Move plugins into the ai-manager orbit
      Create a process for indicating where plugins should be located (ie. tied to device or ai managers)
      Implement some degree of automatic python app registration
        Handshake procedure, etc.
    Make 'Seshat' distributed
      TODO: We'll probably want to create a full distributed file system for this
      TODO: We may want to separate the indexing in the ai-manager and device-manager
        Depending on how we handle networking the search engine, we may want the device-manager to map the paths to their "index results"
          The index results would be any "keys" extracted by the device handlers + the index data (ie. what we get from the search results + ranking data)
          This data would be periodically sent to the ai-manager, which would convert that data into the searchable results (ie. the maps we have already)
    Move the "search" and "dispatch" actions to forward to the ai-manager
    Implement "internal-only" communication actions
      eg. command to update global index (for when a file gets added on a local device)
      This would also add in a lot of "negotiation" messages for internal management
    Extract `loader.py` into common/scripts directory
    Enable sending files across devices
      NOTE: This is especially important for sending rust-plugins to new devices
    See if there's any way to "unify" ai-manager and device-manager
      ie. they should share as much code as possible, maybe not be under two separate folders
  It would be nice if the server could spawn up "One-time use" plugins as needed
  Improve the handshaking procedure to actually have some degree of security and utility
    Current system only works because I have everything hardcoded
  Improve launch script to incorporate some file watching
    Automatically run `setup.py install --user` if anything in the setup script/packages have changed
      Automatically run "build" if cargo modules change
  Improve the configuration system
    Change 'plugin-dir' to take an array of values instead of a single path
  Improve the seshat engine with machine learning capabilities
    This is particularly relevant in filtering the results (such as with mis-spellings)
    Improve granularity of results
      ie. I should be able to search only music files, etc.
        This requires expanding what we store in the index (that or splitting into several indices)
      Look into making an sql-esque interface
  Reduce Technical Debt
    Update 'futures' to use the most recent version
    Ensure that all dependencies are at their most recent versions
    Improve the tracking of files to minimize need for reindexing
      Recognize which data did not come from under a specific root, so we don't have to throw it out if we're re-indexing that root

Long Term:
  Develop my own NLP system for decoding the purpose of messages (Wit doesn't seem to want to adapt)
  Redevelop networking code to better handle shutdowns, etc.
  Figure out how the device manager is supposed to act if I add in an AI node
    I suppose in the final system, the AI node gets setup first, so the server addr exists
    We can also use the udp broadcast system to handle this possibility
      Would need to modify the launcher script to wait until the manager has found the server
  Switch over networking to use udp broadcasting to determine where the servers are
    I'm hardcoding the locations for now as that is simpler for my initial development
// https://github.com/jholtmann/ip_discovery - can use this script during client startup
            // https://gist.github.com/rsolomo/8703190

Errors/Fixes:
  Fix the issues with quit/stop behavior (Seem to have brought everything to a halt)
    Have wit recognize 'quit' and 'stop'
      Wit is absolutely unable to recognize 'quit' as anything other than a search query
    Might want to swap out for LUIS (or even roll my own solution)
